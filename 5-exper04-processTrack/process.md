# 进程运行轨迹的跟踪与统计
## 实验目的
+ 掌握Linux下的多进程编程技术；
+ 通过对进程运行轨迹的跟踪来形象化进程的概念；
+ 在进程运行轨迹跟踪的基础上进行相应的数据统计，从而能对进程调度算法进行实际的量化评价，更进一步加深对调度和调度算法的理解，获得能在实际操作系统上对调度算法进行数据对比的直接经验。

## 实验内容    
进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行......

本次实验包括如下内容：   
+ 基于模板"process.c"编写多进程的样本程序，实现如下功能：
  + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过30秒；
  + 父进程向标准输出打印所有子进程的id，并在多有子进程都退出后才退出；

+ 在Linux0.11上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件/var/process.log，把从操作系统启动到关机过程中所有进程的运行轨迹都记录在这一个log文件中；

+ 在修改过的0.11上运行样本程序，通过分析log文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。

+ 修改0.11进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。

/var/procecess.log文件的格式为：   
```log
pid    X   time    
```    
其中：    
+ pid是进程的ID；
+ X可以使N、J、R、W和E中的任意一个，分别表示进程新建、进入就绪状态、进入运行状态、进入阻塞态、退出；
+ time表示X发生的时间。这个时间不是物理时间，而是系统的滴答时间（tick，此处不清楚可以先查看[系统时间和定时](./system_time.md)）。

## 实验分析
#### 1. main函数    
&emsp;&emsp;init/main.c中的main函数是boot/head.s执行完后接着执行的代码。main函数收先统计物理内存的容量，并对物理内存进行功能划分。然后进行所有方面的硬件初始化工作，包括陷阱门，块设备，字符设备和tty。    
&emsp;&emsp;人工设置任务0(进程0)的PCB以及其在GDT表中的任务状态段描述符tss0和局部描述符表描述符ldt0，然后**通过模拟从特权级变化的内核中断处理过程的返回机制，手动切换到任务0中**（这里的处理非常巧妙）。在任务0中通过fork()系统调用创建出子进程任务1(进程1：init进程)，由init进程进行进一步的处理工作。而任务0不会退出，它会在系统没有进程运行的空闲状态被调度执行，而任务0也只是调用puase()系统调用主动休眠，再次引发系统调度，以检查当前是否有其他进程需要调度。

+ 物理内存的功能划分    
`memory_end`变量记录了以字节为单位的物理内存的容量，并且是页大小(*4KB*)的整数倍。`buffer_memory_end`记录了高速缓冲区的尾端地址，其中包括了用于显存和设备以及ROM BIOS的物理内存。`main_memory_start`记录了主内存区的起始地址，一般来说，`main_memory_start`等于`buffer_memory_end`。如果系统包含虚拟盘，则`main_memory_start`的起始地址相对于`buffer_memory_end`的地址要后移，从而为虚拟盘留出内存空间。
由此可知，系统的物理内存被划分为内核模块，高速缓冲区，虚拟盘，主内存区四大部分。以拥有*16MB*的物理内存的系统为例，下图展示了其物理内存的功能划分：    
![物理内存的功能划分](./images/物理内存的功能划分.png)    
    + mem_map数组    
    **#TODO：**

+ 任务0的内存布局    
&emsp;&emsp;进程控制块PCB是一个task_struct类型的结构体，里面存放系统用于描述进程的所有信息：进程的pid,进程的状态，进程已打开的文件描述符，TSS(Task State Segment，**存放硬件上下文**)和LDT(**存放进程数据段和代码段信息的**)    
  + 操作系统内核堆栈与任务0的内核态堆栈
